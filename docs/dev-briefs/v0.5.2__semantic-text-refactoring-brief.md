# Technical Briefing: Semantic Text Service Refactoring
## Phases 1 & 2 Implementation Guide

**Version:** 1.0  
**Date:** 2025-10-30  
**Target Service:** MGraph-AI Semantic_Text Service  
**Source:** Refactoring from Mitmproxy Service

---

## Executive Summary

This briefing details the refactoring of text transformation logic from the Mitmproxy service to the Semantic_Text service. The goal is to separate HTML manipulation (Mitmproxy) from semantic text intelligence (Semantic_Text), enabling future LLM-based classification and transformation capabilities.

**Key Principles:**
- Mitmproxy handles "how to apply transformations to HTML"
- Semantic_Text handles "what text should be transformed and how"
- Service-to-service communication via HTTP (semantic-text.dev.mgraph.ai)
- Type_Safe patterns throughout with Safe_* primitives
- Comprehensive test coverage following Type_Safe testing patterns

---

## Part 1: Context & Current State

### 1.1 Project Architecture

```
┌─────────────────────────────────────────────────────────┐
│                    Mitmproxy Service                    │
│                 (HTML Manipulation)                     │
├─────────────────────────────────────────────────────────┤
│  ✓ KEEPS:                                               │
│    - HTML__Transformation__Service (orchestration)      │
│    - HTML Service client integration                    │
│    - Cache integration                                  │
│    - HTTP request/response handling                     │
│    - Cookie-based mode selection                        │
│    - Enum__HTML__Transformation_Mode                    │
│                                                         │
│  ✗ REMOVES:                                             │
│    - HTML__Transformation__Service__Local               │
│    - Text__Grouping__Service                            │
│    - Local transformation logic                         │
└─────────────────────────────────────────────────────────┘
                          │
                          ↓ HTTP Calls
┌─────────────────────────────────────────────────────────┐
│                 Semantic_Text Service                   │
│               (Semantic Intelligence)                   │
├─────────────────────────────────────────────────────────┤
│  ✓ NEW COMPONENTS:                                      │
│    - Text__Transformation__Service (orchestration)      │
│    - Text__Grouping__Service (moved from Mitmproxy)    │
│    - Text__Selection__Service (random strategies)       │
│    - New transformation engines:                        │
│      • Text__Transformation__Engine__XXX_Random         │
│      • Text__Transformation__Engine__Hashes_Random      │
│      • Text__Transformation__Engine__ABCDE_By_Size      │
│    - FastAPI routes for transformations                 │
│    - Request/Response schemas                           │
│                                                         │
│  ✗ REMOVES/REFACTORS:                                   │
│    - Semantic_Text__Engine__Random (too simplistic)     │
│    - Current classification schemas (refactor)          │
└─────────────────────────────────────────────────────────┘
```

### 1.2 Current Mitmproxy Implementation

**Location:** `mgraph_ai_service_mitmproxy/service/html/`

**Key Files Being Refactored:**
```python
# TO MOVE TO Semantic_Text:
HTML__Transformation__Service__Local.py    # Local transformation logic
Text__Grouping__Service.py                # Text grouping by length/criteria

# TO KEEP IN Mitmproxy:
HTML__Transformation__Service.py          # Orchestration (updated to call Semantic_Text)
HTML__Service__Client.py                  # HTML Service integration
Enum__HTML__Transformation_Mode.py        # Transformation modes
```

**Current Local Transformations:**
1. **xxx-random**: Randomly mask ~50% of text with 'x' characters
2. **hashes-random**: Randomly show ~50% of text as hash values
3. **abcde-by-size**: Group text by length, replace with letters (a, b, c, d, e)

**Current Flow:**
```python
# 1. Get hash mapping from HTML Service
html_dict, hash_mapping = html_service.get_dict_hashes(html)

# 2. Transform locally (THIS IS MOVING TO Semantic_Text)
modified_mapping = transform_xxx_random(hash_mapping)  

# 3. Reconstruct HTML
transformed_html = html_service.reconstruct_from_hashes(html_dict, modified_mapping)
```

### 1.3 Current Semantic_Text Service

**Location:** `mgraph_ai_service_semantic_text/service/semantic_text/`

**Current Components (Most Will Be Replaced):**
```python
Semantic_Text__Service.py              # Main orchestrator (keep, update)
Semantic_Text__Hashes.py              # Text hashing (keep, may enhance)
Semantic_Text__Engine.py              # Base engine class (keep, update)
Semantic_Text__Engine__Random.py      # Random engine (replace with new engines)
```

**Current Schemas (Need Review):**
```python
Schema__Semantic_Text__Classification.py       # Current classification schema
Enum__Text__Classification__Criteria.py        # Criteria (bias, negativity, etc.)
Enum__Text__Classification__Engine_Mode.py     # Engine modes
Safe_Float__Text__Classification.py            # 0-1 range float
```

---

## Part 2: Architecture Decisions

### 2.1 Service Communication

**Decision:** HTTP service-to-service communication  
**Pattern:** Same as HTML Service integration  
**URL:** `semantic-text.dev.mgraph.ai`  
**Authentication:** API key pattern (ENV vars: `AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__*`)

**Rationale:**
- Clean separation of concerns
- Independently deployable services
- Easier to test and mock
- Enables future scaling

### 2.2 Error Handling

**Decision:** Fallback to original content on Semantic_Text failure  
**Implementation:** Mitmproxy returns original hash_mapping if Semantic_Text unavailable  

```python
# In Mitmproxy:
try:
    transformed_mapping = semantic_text_client.transform(hash_mapping, mode)
except Exception as e:
    log_error(f"Semantic_Text service error: {e}")
    transformed_mapping = hash_mapping  # Fallback to original
```

### 2.3 Caching Strategy

**Decision:** Caching handled in Mitmproxy service  
**Rationale:** 
- Mitmproxy already has sophisticated cache integration
- Semantic_Text remains stateless and focused on transformations
- Simplifies Semantic_Text service design

### 2.4 Testing & Versioning

**Decision:** Version compatibility via comprehensive tests  
**Pattern:** Similar to HTML Service integration testing  
**Strategy:**
- Unit tests for each component
- Integration tests with real HTTP calls
- Mock tests for Mitmproxy integration
- Contract tests between services

---

## Part 3: Phase 1 - Core Components in Semantic_Text

### 3.1 New Service Structure

```
mgraph_ai_service_semantic_text/
├── service/
│   └── text_transformation/                          # NEW DIRECTORY
│       ├── Text__Transformation__Service.py         # Main orchestrator
│       ├── Text__Grouping__Service.py              # Moved from Mitmproxy
│       ├── Text__Selection__Service.py             # New: random selection
│       └── engines/                                # NEW DIRECTORY
│           ├── Text__Transformation__Engine.py                    # Base class
│           ├── Text__Transformation__Engine__XXX_Random.py       # xxx-random logic
│           ├── Text__Transformation__Engine__Hashes_Random.py    # hashes-random logic
│           └── Text__Transformation__Engine__ABCDE_By_Size.py    # abcde-by-size logic
├── schemas/
│   └── transformation/                             # NEW DIRECTORY
│       ├── Schema__Text__Transformation__Request.py     # API request
│       ├── Schema__Text__Transformation__Response.py    # API response
│       ├── Schema__Text__Transformation__Result.py      # Transformation result
│       └── enums/
│           └── Enum__Text__Transformation__Mode.py      # Transformation modes
└── fast_api/
    └── routes/
        └── Routes__Text_Transformation.py          # NEW: API endpoints
```

### 3.2 Schema Specifications

#### Schema__Text__Transformation__Request
```python
from typing                                                                      import Dict
from osbot_utils.type_safe.Type_Safe                                             import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from mgraph_ai_service_semantic_text.schemas.transformation.enums.Enum__Text__Transformation__Mode import Enum__Text__Transformation__Mode

class Schema__Text__Transformation__Request(Type_Safe):                          # Text transformation request
    hash_mapping        : Dict[Safe_Str__Hash, str]                              # Hash → text mapping to transform
    transformation_mode : Enum__Text__Transformation__Mode                       # Which transformation to apply
    randomness_pct      : float                        = 0.5                     # Percentage for random transformations (0.0-1.0)
    group_count         : int                          = 5                       # Number of groups for grouping modes
```

#### Schema__Text__Transformation__Response
```python
from typing                                                                      import Dict, Optional
from osbot_utils.type_safe.Type_Safe                                             import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_Float                            import Safe_Float
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text    import Safe_Str__Text
from mgraph_ai_service_semantic_text.schemas.transformation.enums.Enum__Text__Transformation__Mode import Enum__Text__Transformation__Mode

class Schema__Text__Transformation__Response(Type_Safe):                         # Transformation response with result
    success             : bool                                                   # Whether transformation succeeded
    modified_mapping    : Dict[Safe_Str__Hash, str]                             # Transformed hash mapping
    transformation_mode : Enum__Text__Transformation__Mode                       # Mode that was applied
    processing_time_ms  : Safe_Float                                             # Processing time
    items_transformed   : int                          = 0                       # Count of items modified
    error_message       : Optional[Safe_Str__Text]     = None                    # Error if failed
```

#### Enum__Text__Transformation__Mode
```python
from enum import Enum

class Enum__Text__Transformation__Mode(str, Enum):                               # Text transformation modes
    OFF            = "off"                                                       # No transformation
    XXX_RANDOM     = "xxx-random"                                               # Random masking with 'x'
    HASHES_RANDOM  = "hashes-random"                                            # Show random hashes
    ABCDE_BY_SIZE  = "abcde-by-size"                                            # Group by size with letters
    
    # Future modes:
    # LLM_CLASSIFY   = "llm-classify"                                            # LLM-based classification
    # SEMANTIC_GROUP = "semantic-group"                                          # Semantic similarity grouping
```

### 3.3 Core Service Components

#### Text__Transformation__Service (Main Orchestrator)
```python
from typing                                                                      import Dict
from osbot_utils.type_safe.Type_Safe                                             import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from mgraph_ai_service_semantic_text.schemas.transformation.Schema__Text__Transformation__Request import Schema__Text__Transformation__Request
from mgraph_ai_service_semantic_text.schemas.transformation.Schema__Text__Transformation__Response import Schema__Text__Transformation__Response
from mgraph_ai_service_semantic_text.schemas.transformation.enums.Enum__Text__Transformation__Mode import Enum__Text__Transformation__Mode

class Text__Transformation__Service(Type_Safe):                                  # Main transformation orchestration
    """
    Orchestrates text transformations by routing to appropriate engines.
    
    Responsibilities:
    - Route transformation requests to correct engine
    - Validate transformation requests
    - Track processing metrics
    - Handle errors gracefully
    """
    
    def transform_hash_mapping(self, request : Schema__Text__Transformation__Request  # Transform hash mapping based on mode
                                ) -> Schema__Text__Transformation__Response:          # Transformation result
        """
        Main entry point for text transformations.
        
        Flow:
        1. Validate request
        2. Route to appropriate engine
        3. Execute transformation
        4. Return results with metrics
        """
        pass  # Implementation details below
```

#### Text__Grouping__Service (Moved from Mitmproxy)
```python
from typing                                                                      import Dict, List
from osbot_utils.type_safe.Type_Safe                                             import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_UInt                             import Safe_UInt
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash

class Text__Grouping__Service(Type_Safe):                                        # Group text nodes by various criteria
    """
    Groups text hashes by criteria (length, semantics, etc).
    
    This enables batch processing of similar text nodes, reducing
    LLM calls from O(n) to O(groups).
    
    Example: 100 text nodes → 5 groups → 5 LLM calls instead of 100
    """
    num_groups : Safe_UInt = Safe_UInt(5)                                        # Number of groups to create
    
    def group_by_length(self, hash_mapping : Dict[Safe_Str__Hash, str]           # Group hashes by text length
                         ) -> Dict[int, List[Safe_Str__Hash]]:                   # Group index → list of hashes
        """
        Group text by length into N equal-sized buckets.
        
        Algorithm:
        1. Sort all hashes by text length
        2. Divide into N groups with equal item count
        3. Ensures balanced groups for batch processing
        
        Returns:
            Dict mapping group_index → list of hashes in that group
        """
        pass  # Move implementation from Mitmproxy
    
    def get_group_letter(self, group_index : int                                 # Convert group index to letter
                          ) -> str:                                              # Group letter (a, b, c, etc.)
        """
        Convert group index to letter: 0='a', 1='b', etc.
        
        Supports >26 groups: 26='aa', 27='ab', etc.
        """
        pass  # Move implementation from Mitmproxy
```

#### Text__Selection__Service (New Component)
```python
from typing                                                                      import Dict, List
from osbot_utils.type_safe.Type_Safe                                             import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_Float                            import Safe_Float
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash

class Text__Selection__Service(Type_Safe):                                       # Random selection strategies
    """
    Handles random selection of text nodes for transformation.
    
    Provides configurable percentage-based selection with
    various strategies for future extension.
    """
    randomness_pct : Safe_Float = Safe_Float(0.5)                                # Selection percentage (0.0-1.0)
    
    def select_random_hashes(self, hash_mapping : Dict[Safe_Str__Hash, str]      # Select random subset of hashes
                              ) -> List[Safe_Str__Hash]:                          # Selected hash keys
        """
        Randomly select X% of hashes for transformation.
        
        Algorithm:
        1. Get all hash keys
        2. Calculate selection count (len * randomness_pct)
        3. Use random.sample() for unbiased selection
        
        Returns:
            List of randomly selected hash keys
        """
        pass  # Implementation details below
```

### 3.4 Transformation Engine Implementations

#### Text__Transformation__Engine (Base Class)
```python
from typing                                                                      import Dict
from osbot_utils.type_safe.Type_Safe                                             import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from mgraph_ai_service_semantic_text.schemas.transformation.enums.Enum__Text__Transformation__Mode import Enum__Text__Transformation__Mode

class Text__Transformation__Engine(Type_Safe):                                   # Base class for transformation engines
    """
    Abstract base for all text transformation engines.
    
    Subclasses implement specific transformation strategies.
    """
    transformation_mode : Enum__Text__Transformation__Mode                       # Which mode this engine handles
    
    def transform(self, hash_mapping : Dict[Safe_Str__Hash, str]                 # Transform text mapping
                   ) -> Dict[Safe_Str__Hash, str]:                               # Modified hash mapping
        """
        Transform the hash mapping according to engine strategy.
        
        Subclasses MUST override this method.
        """
        raise NotImplementedError("Subclasses must implement transform()")
```

#### Text__Transformation__Engine__XXX_Random
```python
from typing                                                                      import Dict
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from mgraph_ai_service_semantic_text.service.text_transformation.engines.Text__Transformation__Engine import Text__Transformation__Engine
from mgraph_ai_service_semantic_text.service.text_transformation.Text__Selection__Service import Text__Selection__Service
from mgraph_ai_service_semantic_text.schemas.transformation.enums.Enum__Text__Transformation__Mode import Enum__Text__Transformation__Mode

class Text__Transformation__Engine__XXX_Random(Text__Transformation__Engine):    # Random masking with 'x' characters
    """
    Randomly mask ~50% of text nodes with 'x' characters.
    
    Strategy:
    1. Randomly select X% of hashes
    2. For selected: replace text with 'xxx...' (preserve structure)
    3. For unselected: keep original text
    
    Example:
        Input:  {"hash1": "Hello", "hash2": "World"}
        Output: {"hash1": "xxxxx", "hash2": "World"}
    """
    transformation_mode : Enum__Text__Transformation__Mode = Enum__Text__Transformation__Mode.XXX_RANDOM
    selection_service   : Text__Selection__Service
    
    def transform(self, hash_mapping : Dict[Safe_Str__Hash, str]                 # Transform with xxx masking
                   ) -> Dict[Safe_Str__Hash, str]:                               # Modified mapping
        """
        Apply xxx-random masking transformation.
        
        Implementation moved from Mitmproxy:
        HTML__Transformation__Service__Local.transform_xxx_random_via_hashes()
        """
        pass  # Move logic from Mitmproxy
    
    def mask_text(self, text : str                                               # Mask single text with 'x'
                   ) -> str:                                                      # Masked text
        """
        Replace alphanumeric characters with 'x', preserve structure.
        
        Examples:
            "Hello"        → "xxxxx"
            "Hello World"  → "xxxxx xxxxx"
            "Hello, World!" → "xxxxx, xxxxx!"
        """
        pass  # Move logic from Mitmproxy
```

#### Text__Transformation__Engine__Hashes_Random
```python
from typing                                                                      import Dict
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from mgraph_ai_service_semantic_text.service.text_transformation.engines.Text__Transformation__Engine import Text__Transformation__Engine
from mgraph_ai_service_semantic_text.service.text_transformation.Text__Selection__Service import Text__Selection__Service
from mgraph_ai_service_semantic_text.schemas.transformation.enums.Enum__Text__Transformation__Mode import Enum__Text__Transformation__Mode

class Text__Transformation__Engine__Hashes_Random(Text__Transformation__Engine): # Show random text as hashes
    """
    Randomly replace ~50% of text with their hash values.
    
    Strategy:
    1. Randomly select X% of hashes
    2. For selected: replace text with hash value itself
    3. For unselected: keep original text
    
    Example:
        Input:  {"abc123": "Hello", "def456": "World"}
        Output: {"abc123": "abc123", "def456": "World"}
                (Shows hash instead of text)
    
    Purpose: Debug visualization of hash system
    """
    transformation_mode : Enum__Text__Transformation__Mode = Enum__Text__Transformation__Mode.HASHES_RANDOM
    selection_service   : Text__Selection__Service
    
    def transform(self, hash_mapping : Dict[Safe_Str__Hash, str]                 # Transform to show hashes
                   ) -> Dict[Safe_Str__Hash, str]:                               # Modified mapping
        """
        Apply hashes-random transformation.
        
        Implementation moved from Mitmproxy:
        HTML__Transformation__Service__Local.transform_hashes_random_via_hashes()
        """
        pass  # Move logic from Mitmproxy
```

#### Text__Transformation__Engine__ABCDE_By_Size
```python
from typing                                                                      import Dict
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from mgraph_ai_service_semantic_text.service.text_transformation.engines.Text__Transformation__Engine import Text__Transformation__Engine
from mgraph_ai_service_semantic_text.service.text_transformation.Text__Grouping__Service import Text__Grouping__Service
from mgraph_ai_service_semantic_text.schemas.transformation.enums.Enum__Text__Transformation__Mode import Enum__Text__Transformation__Mode

class Text__Transformation__Engine__ABCDE_By_Size(Text__Transformation__Engine): # Group by size, label with letters
    """
    Group text by length, replace with group letters (a, b, c, d, e).
    
    Strategy:
    1. Group hashes by text length (5 groups)
    2. Replace all text in each group with same letter
    3. Preserves structure (punctuation, whitespace)
    
    Example:
        Short texts  → "aaaa"
        Medium texts → "bbbbb"
        Long texts   → "ccccccccc"
    
    Purpose: Visual length analysis of text nodes
    """
    transformation_mode : Enum__Text__Transformation__Mode = Enum__Text__Transformation__Mode.ABCDE_BY_SIZE
    grouping_service    : Text__Grouping__Service
    
    def transform(self, hash_mapping : Dict[Safe_Str__Hash, str]                 # Transform with group letters
                   ) -> Dict[Safe_Str__Hash, str]:                               # Modified mapping
        """
        Apply abcde-by-size transformation.
        
        Implementation moved from Mitmproxy:
        HTML__Transformation__Service__Local.transform_abcde_by_size_via_hashes()
        """
        pass  # Move logic from Mitmproxy
    
    def replace_with_letter(self, text   : str                    ,              # Replace text with letter
                                  letter : str                                   # Group letter
                             ) -> str:                                           # Replaced text
        """
        Replace alphanumeric with letter, preserve structure.
        
        Examples:
            "Hello", 'a'        → "aaaaa"
            "Hello World", 'b'  → "bbbbb bbbbb"
            "Hello, World!", 'c' → "ccccc, ccccc!"
        """
        pass  # Move logic from Mitmproxy
```

### 3.5 FastAPI Route Implementation

```python
from osbot_fast_api.api.routes.Fast_API__Routes                                           import Fast_API__Routes
from mgraph_ai_service_semantic_text.service.text_transformation.Text__Transformation__Service import Text__Transformation__Service
from mgraph_ai_service_semantic_text.schemas.transformation.Schema__Text__Transformation__Request import Schema__Text__Transformation__Request
from mgraph_ai_service_semantic_text.schemas.transformation.Schema__Text__Transformation__Response import Schema__Text__Transformation__Response

TAG__ROUTES_TEXT_TRANSFORMATION = 'text-transformation'

class Routes__Text_Transformation(Fast_API__Routes):                             # FastAPI routes for text transformation
    tag                            : str = TAG__ROUTES_TEXT_TRANSFORMATION
    text_transformation_service    : Text__Transformation__Service = None
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.text_transformation_service = Text__Transformation__Service().setup()
    
    def transform(self, request : Schema__Text__Transformation__Request          # Transform text hash mapping
                   ) -> Schema__Text__Transformation__Response:                  # Transformation result
        """
        POST /text-transformation/transform
        
        Transform text hash mapping according to specified mode.
        
        Request Body:
        {
            "hash_mapping": {"hash1": "text1", "hash2": "text2"},
            "transformation_mode": "xxx-random",
            "randomness_pct": 0.5,
            "group_count": 5
        }
        
        Response:
        {
            "success": true,
            "modified_mapping": {"hash1": "xxxxx", "hash2": "text2"},
            "transformation_mode": "xxx-random",
            "processing_time_ms": 12.5,
            "items_transformed": 1
        }
        """
        return self.text_transformation_service.transform_hash_mapping(request)
    
    def setup_routes(self):
        self.add_route_post(self.transform)
```

---

## Part 4: Phase 2 - Mitmproxy Integration

### 4.1 Semantic_Text Service Client

**Location:** `mgraph_ai_service_mitmproxy/service/semantic_text/`

```python
import requests
from typing                                                                      import Dict, Optional
from osbot_utils.type_safe.Type_Safe                                             import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_Float                            import Safe_Float
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.utils.Env                                                       import get_env

# Import Semantic_Text schemas (shared via package dependency)
from mgraph_ai_service_semantic_text.schemas.transformation.Schema__Text__Transformation__Request import Schema__Text__Transformation__Request
from mgraph_ai_service_semantic_text.schemas.transformation.Schema__Text__Transformation__Response import Schema__Text__Transformation__Response
from mgraph_ai_service_semantic_text.schemas.transformation.enums.Enum__Text__Transformation__Mode import Enum__Text__Transformation__Mode

# Environment variables for Semantic_Text service
ENV_VAR__SEMANTIC_TEXT_SERVICE__BASE_URL  = "AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__BASE_URL"
ENV_VAR__SEMANTIC_TEXT_SERVICE__KEY_NAME  = "AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_NAME"
ENV_VAR__SEMANTIC_TEXT_SERVICE__KEY_VALUE = "AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_VALUE"

DEFAULT__SEMANTIC_TEXT_SERVICE__BASE_URL = "https://semantic-text.dev.mgraph.ai"
DEFAULT__SEMANTIC_TEXT_SERVICE__TIMEOUT  = 30.0

class Semantic_Text__Service__Client(Type_Safe):                                 # HTTP client for Semantic_Text Service
    """
    Client for calling Semantic_Text service transformations.
    
    Pattern: Same as HTML__Service__Client
    Authentication: API key via environment variables
    """
    base_url : str        = DEFAULT__SEMANTIC_TEXT_SERVICE__BASE_URL
    timeout  : Safe_Float = Safe_Float(DEFAULT__SEMANTIC_TEXT_SERVICE__TIMEOUT)
    
    def setup(self) -> 'Semantic_Text__Service__Client':                         # Setup with environment config
        base_url_env = get_env(ENV_VAR__SEMANTIC_TEXT_SERVICE__BASE_URL)
        if base_url_env:
            self.base_url = base_url_env
        return self
    
    def get_auth_headers(self) -> Dict[str, str]:                                # Get authentication headers
        key_name  = get_env(ENV_VAR__SEMANTIC_TEXT_SERVICE__KEY_NAME)
        key_value = get_env(ENV_VAR__SEMANTIC_TEXT_SERVICE__KEY_VALUE)
        
        headers = {"Content-Type": "application/json"}
        if key_name and key_value:
            headers[key_name] = key_value
        
        return headers
    
    def transform_hash_mapping(self, 
                              hash_mapping        : Dict[Safe_Str__Hash, str]    ,  # Hash mapping to transform
                              transformation_mode : Enum__Text__Transformation__Mode,  # Transformation mode
                              randomness_pct      : float = 0.5                  ,  # Randomness percentage
                              group_count         : int   = 5                       # Group count
                               ) -> Optional[Schema__Text__Transformation__Response]: # Transformation result or None
        """
        Call Semantic_Text service to transform hash mapping.
        
        Returns None on failure (caller should fallback to original).
        """
        url     = f"{self.base_url}/text-transformation/transform"
        headers = self.get_auth_headers()
        
        request = Schema__Text__Transformation__Request(
            hash_mapping        = hash_mapping,
            transformation_mode = transformation_mode,
            randomness_pct      = randomness_pct,
            group_count         = group_count
        )
        
        try:
            response = requests.post(url     = url                     ,
                                    headers = headers                 ,
                                    json    = request.json()          ,
                                    timeout = float(self.timeout)     )
            
            if response.status_code == 200:
                data = response.json()
                return Schema__Text__Transformation__Response(**data)
            else:
                print(f"⚠️  Semantic_Text service error: {response.status_code}")
                return None
                
        except requests.Timeout:
            print(f"⚠️  Semantic_Text service timeout after {self.timeout}s")
            return None
        except Exception as e:
            print(f"⚠️  Semantic_Text service error: {e}")
            return None
```

### 4.2 Updated HTML__Transformation__Service

**Changes to:** `mgraph_ai_service_mitmproxy/service/html/HTML__Transformation__Service.py`

**Key Changes:**
1. Add Semantic_Text client
2. Remove `HTML__Transformation__Service__Local` dependency
3. Update `_transform_locally()` to call Semantic_Text service
4. Add fallback to original on service failure

```python
# Updated method in HTML__Transformation__Service

from mgraph_ai_service_mitmproxy.service.semantic_text.Semantic_Text__Service__Client import Semantic_Text__Service__Client

class HTML__Transformation__Service(Type_Safe):
    # ... existing fields ...
    semantic_text_client : Semantic_Text__Service__Client = None                 # NEW: Semantic_Text client
    
    def setup(self) -> 'HTML__Transformation__Service':
        self.html_service_client = HTML__Service__Client().setup()
        self.cache_service       = Proxy__Cache__Service().setup()
        self.semantic_text_client = Semantic_Text__Service__Client().setup()     # NEW
        return self
    
    def _transform_locally(self,
                          source_html : str,
                          mode        : Enum__HTML__Transformation_Mode
                         ) -> Schema__HTML__Transformation__Result:
        """
        UPDATED: Now calls Semantic_Text service instead of local processing.
        
        Flow:
        1. Get hash mapping from HTML Service
        2. Call Semantic_Text service to transform mapping
        3. Reconstruct HTML from transformed mapping
        4. Fallback to original on any failure
        """
        import time
        start_time = time.time()
        
        try:
            # Step 1: Get hash mapping from HTML Service
            dict_hashes_request = Schema__Html__To__Dict__Hashes__Request(html=source_html)
            dict_hashes_response = self.html_service_client.get_dict_hashes(dict_hashes_request)
            
            if not dict_hashes_response.is_successful():
                return self._error_result(source_html, mode, start_time)
            
            html_dict = dict_hashes_response.html_dict
            hash_mapping = dict_hashes_response.hash_mapping
            
            # Step 2: Call Semantic_Text service to transform mapping
            # Map HTML transformation mode to Text transformation mode
            text_mode = self._map_html_mode_to_text_mode(mode)
            
            transformation_response = self.semantic_text_client.transform_hash_mapping(
                hash_mapping        = hash_mapping,
                transformation_mode = text_mode,
                randomness_pct      = 0.5,
                group_count         = 5
            )
            
            # Fallback on failure
            if not transformation_response or not transformation_response.success:
                print(f"⚠️  Semantic_Text transformation failed, using original")
                return self._error_result(source_html, mode, start_time)
            
            modified_mapping = transformation_response.modified_mapping
            
            # Step 3: Reconstruct HTML
            reconstruct_request = Schema__Hashes__To__Html__Request(
                html_dict    = html_dict,
                hash_mapping = modified_mapping
            )
            reconstruct_response = self.html_service_client.reconstruct_from_hashes(reconstruct_request)
            
            if not reconstruct_response.is_successful():
                return self._error_result(source_html, mode, start_time)
            
            # Success!
            call_duration_ms = (time.time() - start_time) * 1000
            
            return Schema__HTML__Transformation__Result(
                transformed_html       = reconstruct_response.body,
                transformation_mode    = mode,
                content_type           = "text/html",
                cache_hit              = False,
                transformation_time_ms = Safe_Float(call_duration_ms)
            )
            
        except Exception as e:
            print(f"⚠️  Local transformation error: {e}")
            return self._error_result(source_html, mode, start_time)
    
    def _map_html_mode_to_text_mode(self, 
                                   html_mode: Enum__HTML__Transformation_Mode
                                   ) -> Enum__Text__Transformation__Mode:          # Map HTML mode to Text mode
        """
        Map HTML transformation mode to Semantic_Text transformation mode.
        
        Mapping:
        - XXX_RANDOM     → XXX_RANDOM
        - HASHES_RANDOM  → HASHES_RANDOM
        - ABCDE_BY_SIZE  → ABCDE_BY_SIZE
        """
        from mgraph_ai_service_semantic_text.schemas.transformation.enums.Enum__Text__Transformation__Mode import Enum__Text__Transformation__Mode
        
        mapping = {
            Enum__HTML__Transformation_Mode.XXX_RANDOM    : Enum__Text__Transformation__Mode.XXX_RANDOM,
            Enum__HTML__Transformation_Mode.HASHES_RANDOM : Enum__Text__Transformation__Mode.HASHES_RANDOM,
            Enum__HTML__Transformation_Mode.ABCDE_BY_SIZE : Enum__Text__Transformation__Mode.ABCDE_BY_SIZE,
        }
        
        return mapping.get(html_mode, Enum__Text__Transformation__Mode.OFF)
```

### 4.3 Files to Remove from Mitmproxy

After Phase 2 completion, **DELETE** these files:
```
mgraph_ai_service_mitmproxy/service/html/HTML__Transformation__Service__Local.py
mgraph_ai_service_mitmproxy/service/html/Text__Grouping__Service.py
```

---

## Part 5: Type_Safe Code Patterns

### 5.1 Critical Type_Safe Rules

**NEVER use raw primitives** - Always use Safe_* types:
```python
# ✗ WRONG
class MyClass(Type_Safe):
    name: str           # Dangerous - unlimited length, no validation
    count: int          # Dangerous - can overflow, be negative
    
# ✓ CORRECT
class MyClass(Type_Safe):
    name: Safe_Str__Text                                                         # Length-limited, sanitized
    count: Safe_UInt                                                             # Non-negative, validated
```

**Always inherit from Type_Safe:**
```python
from osbot_utils.type_safe.Type_Safe import Type_Safe

class MyClass(Type_Safe):    # ✓ REQUIRED
    field: str
```

**Type annotate everything:**
```python
class Config(Type_Safe):
    host: str                                                                    # ✓ Annotated
    port: int                                                                    # ✓ Annotated
    # items = []                                                                 # ✗ WRONG - Missing annotation
```

**Use @type_safe for method validation:**
```python
from osbot_utils.type_safe.type_safe_core.decorators.type_safe import type_safe

class Service(Type_Safe):
    @type_safe                                                                   # Validates params and return
    def process(self, data: str) -> int:
        return len(data)
```

### 5.2 Formatting Rules

**Method signatures with alignment:**
```python
def method_name(self, first_param  : Type1        ,                              # Purpose comment
                      second_param : Type2        ,                              # At column 80
                      third_param  : Type3 = None                                # Default values
                ) -> ReturnType:                                                 # Return type
    """Method does X, Y, Z"""
    pass
```

**Vertical alignment for related data:**
```python
class Schema__User(Type_Safe):
    id         : Safe_Id                                                         # Primary key
    name       : Safe_Str__Text                                                  # Display name
    email      : Safe_Str__Email                                                 # Contact
    created_at : Timestamp_Now                                                   # When created
```

**NEVER use docstrings in tests:**
```python
# ✓ CORRECT
def test__init__(self):                                                          # Test initialization
    with MyClass() as _:
        assert type(_) is MyClass

# ✗ WRONG
def test__init__(self):
    """Test initialization"""                                                   # NO! Breaks alignment
    with MyClass() as _:
        assert type(_) is MyClass
```

### 5.3 Available Safe_* Types

**Common:**
- `Safe_Str__Text` - General text with length limits
- `Safe_Str__Version` - Version strings
- `Safe_UInt` - Non-negative integers
- `Safe_Float` - Floating point with validation

**Identifiers:**
- `Safe_Id` / `Safe_Str__Id` - Generic IDs
- `Random_Guid` - Auto-generated UUIDs
- `Timestamp_Now` - Auto-generated timestamps

**Domain-Specific:**
- `Safe_Str__Hash` - Cryptographic hashes
- `Safe_Str__Url` - URLs
- `Safe_Str__File__Path` - File paths
- `Safe_Float__Money` - Financial calculations

---

## Part 6: Testing Requirements

### 6.1 Test Structure

```
tests/
├── unit/
│   └── service/
│       └── text_transformation/
│           ├── test_Text__Transformation__Service.py
│           ├── test_Text__Grouping__Service.py
│           ├── test_Text__Selection__Service.py
│           └── engines/
│               ├── test_Text__Transformation__Engine__XXX_Random.py
│               ├── test_Text__Transformation__Engine__Hashes_Random.py
│               └── test_Text__Transformation__Engine__ABCDE_By_Size.py
└── integration/
    └── fast_api/
        └── routes/
            └── test_Routes__Text_Transformation.py
```

### 6.2 Test Patterns

**Context manager with underscore:**
```python
def test__init__(self):                                                          # Test initialization
    with Text__Transformation__Service() as _:
        assert type(_) is Text__Transformation__Service
        assert _.transformation_mode is not None
```

**Use .obj() for comprehensive checks:**
```python
from osbot_utils.testing.__ import __

def test__transform(self):                                                       # Test transformation
    with Text__Transformation__Engine__XXX_Random() as _:
        hash_mapping = {"abc123": "Hello World"}
        result = _.transform(hash_mapping)
        
        # Single comprehensive assertion
        assert result.obj() == __(
            abc123 = "xxxxx xxxxx"                                               # Masked text
        )
```

**Use __SKIP__ for dynamic values:**
```python
def test__response(self):                                                        # Test API response
    with Schema__Text__Transformation__Response() as _:
        _.success = True
        _.processing_time_ms = Safe_Float(12.5)
        
        assert _.obj() == __(success             = True      ,
                            modified_mapping    = {}         ,
                            transformation_mode = __SKIP__   ,                   # Auto-generated
                            processing_time_ms  = 12.5       )
```

**Method naming convention:**
```python
class test_Text__Transformation__Service(TestCase):
    def test__init__(self): pass                                                 # Always test __init__
    def test_transform_hash_mapping(self): pass                                  # Maps to method
    def test_transform_hash_mapping__with_empty_input(self): pass                # Variation
    def test__integration_full_flow(self): pass                                  # Cross-method test
```

### 6.3 Essential Tests for Each Component

**Every Type_Safe class needs:**
- [ ] `test__init__` - Verify Type_Safe inheritance and auto-initialization
- [ ] `test_<method_name>` - One test per public method
- [ ] Type enforcement tests with valid/invalid inputs
- [ ] JSON serialization round-trip tests
- [ ] Use `.obj()` for state verification

**FastAPI routes need:**
- [ ] Valid request/response tests
- [ ] Error handling tests (invalid input, service failures)
- [ ] Authentication tests
- [ ] Integration tests with real service

**Services need:**
- [ ] Setup/initialization tests
- [ ] Business logic tests for each method
- [ ] Error handling and fallback tests
- [ ] State management tests

---

## Part 7: Implementation Checklist

### Phase 1: Semantic_Text Service

**Components:**
- [ ] Create `service/text_transformation/` directory structure
- [ ] Implement `Text__Transformation__Service` with routing logic
- [ ] Move `Text__Grouping__Service` from Mitmproxy
- [ ] Implement `Text__Selection__Service` for random selection
- [ ] Implement base `Text__Transformation__Engine`
- [ ] Implement `Text__Transformation__Engine__XXX_Random`
- [ ] Implement `Text__Transformation__Engine__Hashes_Random`
- [ ] Implement `Text__Transformation__Engine__ABCDE_By_Size`

**Schemas:**
- [ ] Create `schemas/transformation/` directory
- [ ] Implement `Schema__Text__Transformation__Request`
- [ ] Implement `Schema__Text__Transformation__Response`
- [ ] Implement `Enum__Text__Transformation__Mode`

**API:**
- [ ] Implement `Routes__Text_Transformation`
- [ ] Add route to `Service__Fast_API` setup
- [ ] Test endpoints with FastAPI test client

**Tests:**
- [ ] Unit tests for all services
- [ ] Unit tests for all engines
- [ ] Unit tests for schemas
- [ ] Integration tests for API routes
- [ ] Test error handling and edge cases

**Documentation:**
- [ ] Update README with new endpoints
- [ ] Document transformation modes
- [ ] Add examples for each transformation

### Phase 2: Mitmproxy Integration

**Components:**
- [ ] Create `service/semantic_text/` directory in Mitmproxy
- [ ] Implement `Semantic_Text__Service__Client`
- [ ] Update `HTML__Transformation__Service` to use client
- [ ] Add environment variable configuration
- [ ] Implement mode mapping (HTML → Text)
- [ ] Add fallback logic for service failures

**Cleanup:**
- [ ] Remove `HTML__Transformation__Service__Local.py`
- [ ] Remove `Text__Grouping__Service.py` from Mitmproxy
- [ ] Update imports throughout Mitmproxy
- [ ] Clean up unused dependencies

**Tests:**
- [ ] Unit tests for Semantic_Text client
- [ ] Mock tests for client error handling
- [ ] Integration tests with real Semantic_Text service
- [ ] End-to-end tests through full transformation flow
- [ ] Test fallback behavior on service failure

**Deployment:**
- [ ] Add environment variables to deployment configs
- [ ] Update Lambda dependencies
- [ ] Deploy Semantic_Text service to semantic-text.dev.mgraph.ai
- [ ] Verify Mitmproxy can reach new service
- [ ] Monitor logs for errors

---

## Part 8: Success Criteria

### Functional Requirements

✅ **Semantic_Text Service:**
- Accepts hash mapping transformation requests via HTTP POST
- Returns transformed hash mapping with metrics
- Supports xxx-random, hashes-random, abcde-by-size modes
- Handles errors gracefully with clear error messages
- Responds within 30 seconds (timeout limit)

✅ **Mitmproxy Integration:**
- Successfully calls Semantic_Text service for local transformations
- Falls back to original content on service failure
- Maintains existing transformation behavior for users
- No breaking changes to existing functionality
- Logs clear messages for service calls and errors

### Non-Functional Requirements

✅ **Code Quality:**
- All classes inherit from Type_Safe
- No raw primitives (str, int, float) - only Safe_* types
- Proper type annotations on all attributes and methods
- Follows vertical alignment formatting rules
- Comprehensive inline comments (no docstrings in tests)

✅ **Testing:**
- >90% test coverage for new components
- All Type_Safe classes have test__init__
- Integration tests pass with real HTTP calls
- Mock tests verify error handling
- Tests use context managers and .obj()

✅ **Performance:**
- Transformation time < 2 seconds for typical requests
- Service startup < 5 seconds
- No memory leaks in long-running processes

✅ **Documentation:**
- All public methods have inline comments
- README updated with new capabilities
- API examples provided
- Deployment instructions clear

---

## Part 9: Future Enhancements

### After Phase 2 Completion

**LLM-Based Transformations (Phase 3):**
- Implement `Text__Transformation__Engine__LLM_Classify`
- Add `Schema__LLM__Classification__Request`
- Integrate with LLM service for semantic analysis
- Support privacy-aware classification

**Semantic Grouping (Phase 4):**
- Implement `Text__Grouping__Service.group_by_semantics()`
- Add embedding-based clustering
- Group similar content together
- Reduce LLM calls via batch processing

**Advanced Features (Phase 5):**
- Content-aware masking (protect PII)
- Sentiment-based transformations
- Domain-specific text analysis
- Caching in Semantic_Text service

---

## Part 10: Reference Information

### Key Files

**Semantic_Text Service:**
- `mgraph_ai_service_semantic_text/service/text_transformation/Text__Transformation__Service.py`
- `mgraph_ai_service_semantic_text/fast_api/routes/Routes__Text_Transformation.py`
- `mgraph_ai_service_semantic_text/schemas/transformation/Schema__Text__Transformation__Request.py`

**Mitmproxy Service:**
- `mgraph_ai_service_mitmproxy/service/html/HTML__Transformation__Service.py`
- `mgraph_ai_service_mitmproxy/service/semantic_text/Semantic_Text__Service__Client.py`

**Original Implementation (for reference):**
- `mgraph_ai_service_mitmproxy/service/html/HTML__Transformation__Service__Local.py`
- `mgraph_ai_service_mitmproxy/service/html/Text__Grouping__Service.py`

### Environment Variables

```bash
# Semantic_Text Service
AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__BASE_URL="https://semantic-text.dev.mgraph.ai"
AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_NAME="X-API-Key"
AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_VALUE="your-secret-key"

# HTML Service (existing)
AUTH__TARGET_SERVER__HTML_SERVICE__BASE_URL="https://html.dev.mgraph.ai"
AUTH__TARGET_SERVER__HTML_SERVICE__KEY_NAME="X-API-Key"
AUTH__TARGET_SERVER__HTML_SERVICE__KEY_VALUE="your-secret-key"
```

### Dependencies

**Add to Semantic_Text:**
- None (uses existing osbot-utils, osbot-fast-api)

**Add to Mitmproxy:**
- Package dependency on mgraph_ai_service_semantic_text (for shared schemas)

---

## Conclusion

This refactoring creates a clean separation between HTML manipulation and semantic text intelligence. The Semantic_Text service becomes the authoritative source for text transformation logic, enabling future LLM-based enhancements while keeping the Mitmproxy service focused on its core HTTP proxying responsibilities.

The implementation follows Type_Safe patterns throughout, ensuring runtime type safety and maintainable code. Comprehensive testing at unit and integration levels ensures reliability and correctness.

Upon completion, both services will be independently deployable, testable, and extensible.