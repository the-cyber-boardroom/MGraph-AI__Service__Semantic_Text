# LLM Brief: Mitmproxy Service Integration with Semantic Text API

**Version:** v0.5.20  
**Date:** 2025-01-11  
**Status:** Refactoring Plan  
**Related:** v0.5.2__semantic-text-refactoring-brief.md  , v0.5.20__technical-brief__mitmproxy-service-integration-with-semantic-text-api.md

---

## 1. Executive Summary

This brief outlines the refactoring required to integrate the new Semantic Text API into the mitmproxy service, replacing the current local text transformation implementations and removing deprecated WCF service dependencies.

**Goals:**
- Migrate text transformations (`xxx-random`, `hashes-random`, `abcde-by-size`) to Semantic Text API
- Remove all WCF service code (`url_to_*` commands and related infrastructure)
- Maintain backward compatibility for HTML Service transformations (`dict`, `xxx`, `hashes`, `roundtrip`)
- Preserve existing cache structure and behavior
- Ensure zero breaking changes for mitmproxy API consumers

---

## 2. Semantic Text API Overview

### 2.1 Service Configuration

**Base URL:** `https://semantic-text.dev.mgraph.ai/`  
**Authentication:** API Key via custom header (similar to HTML Service pattern)  
**Environment Variables:**
```
AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__BASE_URL
AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_NAME
AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_VALUE
```

### 2.2 Relevant Endpoints

#### Text Transformation Endpoints
| Endpoint | Method | Purpose | Maps From |
|----------|--------|---------|-----------|
| `/text-transformation/transform/xxx-random` | POST | Random text masking | Local: `HTML__Transformation__Service__Local.transform_xxx_random_via_hashes()` |
| `/text-transformation/transform/hashes-random` | POST | Random hash display | Local: `HTML__Transformation__Service__Local.transform_hashes_random_via_hashes()` |
| `/text-transformation/transform/abcde-by-size` | POST | Group by text size | Local: `HTML__Transformation__Service__Local.transform_abcde_by_size_via_hashes()` |

#### Classification Endpoints (Future Use)
| Endpoint | Method | Purpose | Notes |
|----------|--------|---------|-------|
| `/semantic-classification/single/rate` | POST | Single criteria rating | Not currently used, available for future features |
| `/semantic-classification/single/filter` | POST | Single criteria filtering | Not currently used, available for future features |
| `/semantic-classification/multi/rate` | POST | Multi-criteria rating | Not currently used, available for future features |
| `/semantic-classification/multi/filter` | POST | Multi-criteria filtering | Not currently used, available for future features |

---

## 3. Current Architecture Analysis

### 3.1 Transformation Flow (Current)

```
Browser Request (mitm-mode cookie)
    â†“
Proxy__Cookie__Service.get_mitm_mode()
    â†“
Proxy__Response__Service.process_html_transformation()
    â†“
HTML__Transformation__Service.transform_html()
    â”œâ”€â†’ [DICT/XXX/HASHES/ROUNDTRIP] â†’ HTML__Service__Client â†’ HTML Service
    â””â”€â†’ [XXX_RANDOM/HASHES_RANDOM/ABCDE_BY_SIZE] â†’ HTML__Transformation__Service__Local
        â†“
        HTML__Service__Client.get_dict_hashes() â†’ HTML Service
        â†“
        LOCAL: transform_xxx_random_via_hashes() / transform_hashes_random_via_hashes() / transform_abcde_by_size_via_hashes()
        â†“
        HTML__Service__Client.reconstruct_from_hashes() â†’ HTML Service
```

### 3.2 WCF Architecture (To Remove)

```
Debug Command (show=url-to-html)
    â†“
Proxy__Debug__Service.process_show_command()
    â†“
Proxy__WCF__Service.process_show_command()
    â”œâ”€â†’ WCF__Command__Processor.parse_show_command()
    â”œâ”€â†’ WCF__Cache__Integrator.try_get_cached_response()
    â””â”€â†’ WCF__Request__Handler.make_request() â†’ WCF Service
```

---

## 4. Target Architecture

### 4.1 New Transformation Flow

```
Browser Request (mitm-mode cookie)
    â†“
Proxy__Cookie__Service.get_mitm_mode()
    â†“
Proxy__Response__Service.process_html_transformation()
    â†“
HTML__Transformation__Service.transform_html()
    â”œâ”€â†’ [DICT/XXX/HASHES/ROUNDTRIP] â†’ HTML__Service__Client â†’ HTML Service
    â””â”€â†’ [XXX_RANDOM/HASHES_RANDOM/ABCDE_BY_SIZE] â†’ Semantic_Text__Service__Client â†’ Semantic Text Service
        â†“
        (No local processing - all handled by Semantic Text API)
```

### 4.2 Service Integration Points

**HTML Service** (Unchanged):
- `POST /html/to/dict/hashes` - Get hash mapping
- `POST /hashes/to/html` - Reconstruct HTML
- `POST /html/to/tree/view` - Tree view (DICT mode)
- `POST /html/to/html/xxx` - Full masking (XXX mode)
- `POST /html/to/html/hashes` - Hash display (HASHES mode)
- `POST /html/to/html` - Roundtrip (ROUNDTRIP mode)

**Semantic Text Service** (New Integration):
- `POST /text-transformation/transform/xxx-random` - Random masking
- `POST /text-transformation/transform/hashes-random` - Random hash display
- `POST /text-transformation/transform/abcde-by-size` - Size-based grouping

---

## 5. Files to Remove/Deprecate

### 5.1 Complete Removal (WCF Service Code)

**Service Layer:**
```
âœ— service/wcf/Proxy__WCF__Service.py
âœ— service/wcf/WCF__Request__Handler.py
âœ— service/wcf/WCF__Cache__Integrator.py
âœ— service/wcf/WCF__Command__Processor.py
âœ— service/wcf/__init__.py
```

**Schema Layer:**
```
âœ— schemas/wcf/Schema__WCF__Request.py
âœ— schemas/wcf/Schema__WCF__Response.py
âœ— schemas/wcf/__init__.py
âœ— schemas/proxy/Enum__WCF__Command_Type.py
âœ— schemas/proxy/Enum__WCF__Content_Type.py
```

### 5.2 Deprecate/Remove (Local Text Transformation)

**Service Layer:**
```
âœ— service/html/HTML__Transformation__Service__Local.py
âœ— service/html/Text__Grouping__Service.py
```

**Methods to Remove from `HTML__Transformation__Service`:**
```python
âœ— _transform_locally()
âœ— _error_result()
```

### 5.3 Update Required (Integration Points)

**Files requiring modification:**
```
â†» service/html/HTML__Transformation__Service.py
â†» service/proxy/Proxy__Debug__Service.py
â†» schemas/html/Enum__HTML__Transformation_Mode.py
â†» service/cache/schemas/Enum__Cache__Transformation_Type.py
```

---

## 6. Files to Create

### 6.1 Service Layer

#### `service/semantic_text/Semantic_Text__Service__Client.py`
```python
class Semantic_Text__Service__Client(Type_Safe):
    """HTTP client for Semantic Text Service API"""
    base_url : str
    timeout  : Safe_Float
    
    def setup(self) -> 'Semantic_Text__Service__Client'
    def get_auth_headers(self) -> dict
    def transform_text(self, request: Schema__Semantic_Text__Request) -> Schema__Semantic_Text__Response
```

**Purpose:** HTTP client for making requests to Semantic Text Service  
**Pattern:** Mirror `HTML__Service__Client.py`  
**Authentication:** Environment variable based (similar to HTML Service)

---

#### `service/semantic_text/Semantic_Text__Transformation__Service.py`
```python
class Semantic_Text__Transformation__Service(Type_Safe):
    """Orchestrates text transformations via Semantic Text API"""
    client       : Semantic_Text__Service__Client
    cache_service: Proxy__Cache__Service
    
    def setup(self) -> 'Semantic_Text__Transformation__Service'
    def transform_text(self, hash_mapping: Dict[Safe_Str__Hash, str], 
                      mode: Enum__Semantic_Text__Transformation_Mode) -> Dict[Safe_Str__Hash, str]
    def _get_cached_transformation(self, cache_key: str) -> Optional[Dict]
    def _store_transformation(self, cache_key: str, result: Dict) -> None
```

**Purpose:** High-level orchestration with caching  
**Pattern:** Similar to `HTML__Transformation__Service.py` but focused on text-only transformations  
**Responsibilities:**
- Cache integration
- Request/response mapping
- Error handling

---

### 6.2 Schema Layer

#### `schemas/semantic_text/Enum__Semantic_Text__Transformation_Mode.py`
```python
class Enum__Semantic_Text__Transformation_Mode(str, Enum):
    """Semantic Text transformation modes"""
    XXX_RANDOM    = "xxx-random"
    HASHES_RANDOM = "hashes-random"
    ABCDE_BY_SIZE = "abcde-by-size"
    
    def to_endpoint_path(self) -> str
    def to_cache_data_key(self) -> str
```

**Purpose:** Type-safe enum for transformation modes  
**Maps To:** Semantic Text API endpoints

---

#### `schemas/semantic_text/Schema__Semantic_Text__Request.py`
```python
class Schema__Semantic_Text__Request__Base(Type_Safe):
    """Base request for all Semantic Text transformations"""
    hash_mapping           : Dict[Safe_Str__Hash, str]
    randomness_percentage  : Safe_Float = 0.5

class Schema__Semantic_Text__Request__XXX_Random(Schema__Semantic_Text__Request__Base):
    """Request for xxx-random transformation"""
    pass

class Schema__Semantic_Text__Request__Hashes_Random(Schema__Semantic_Text__Request__Base):
    """Request for hashes-random transformation"""
    pass

class Schema__Semantic_Text__Request__ABCDE_By_Size(Schema__Semantic_Text__Request__Base):
    """Request for abcde-by-size transformation"""
    num_groups : Safe_UInt = 5
```

**Purpose:** Request schemas for Semantic Text API  
**Maps To:** OpenAPI schemas from Semantic Text Service  
**Pattern:** Type-Safe classes for validation

---

#### `schemas/semantic_text/Schema__Semantic_Text__Response.py`
```python
class Schema__Semantic_Text__Response(Type_Safe):
    """Response from Semantic Text Service"""
    status_code          : Safe_UInt
    modified_hash_mapping: Dict[Safe_Str__Hash, str]
    success              : bool
    error_message        : Optional[Safe_Str__Text] = None
    processing_time_ms   : Safe_Float
    
    def is_successful(self) -> bool
```

**Purpose:** Response schema from Semantic Text API  
**Standardization:** Consistent error handling and success checking

---

#### `schemas/semantic_text/Schema__Semantic_Text__Transformation__Result.py`
```python
class Schema__Semantic_Text__Transformation__Result(Type_Safe):
    """Result of text transformation operation"""
    modified_hash_mapping : Dict[Safe_Str__Hash, str]
    transformation_mode   : Enum__Semantic_Text__Transformation_Mode
    cache_hit             : bool
    transformation_time_ms: Safe_Float
    
    def was_cached(self) -> bool
```

**Purpose:** Internal result tracking  
**Pattern:** Similar to `Schema__HTML__Transformation__Result`

---

### 6.3 Constants

#### `service/consts/consts__semantic_text.py`
```python
ENV_VAR__AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__BASE_URL  = "AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__BASE_URL"
ENV_VAR__AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_NAME  = "AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_NAME"
ENV_VAR__AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_VALUE = "AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_VALUE"

DEFAULT__SEMANTIC_TEXT_SERVICE__BASE_URL = "https://semantic-text.dev.mgraph.ai"
DEFAULT__SEMANTIC_TEXT_SERVICE__TIMEOUT  = 30.0
```

---

## 7. Files to Modify

### 7.1 `schemas/html/Enum__HTML__Transformation_Mode.py`

**Changes Required:**

```python
class Enum__HTML__Transformation_Mode(str, Enum):
    OFF           = "off"
    
    # HTML Service transformations (KEEP)
    DICT          = "dict"
    XXX           = "xxx"
    HASHES        = "hashes"
    ROUNDTRIP     = "roundtrip"
    
    # Semantic Text transformations (MIGRATE)
    XXX_RANDOM    = "xxx-random"
    HASHES_RANDOM = "hashes-random"
    ABCDE_BY_SIZE = "abcde-by-size"
    
    def is_html_service_transformation(self) -> bool:
        """Check if this uses HTML Service"""
        return self in (
            Enum__HTML__Transformation_Mode.DICT,
            Enum__HTML__Transformation_Mode.XXX,
            Enum__HTML__Transformation_Mode.HASHES,
            Enum__HTML__Transformation_Mode.ROUNDTRIP
        )
    
    def is_semantic_text_transformation(self) -> bool:
        """Check if this uses Semantic Text Service"""
        return self in (
            Enum__HTML__Transformation_Mode.XXX_RANDOM,
            Enum__HTML__Transformation_Mode.HASHES_RANDOM,
            Enum__HTML__Transformation_Mode.ABCDE_BY_SIZE
        )
    
    # REMOVE: is_local_transformation() - no longer needed
```

**Rationale:** Clear separation between HTML Service and Semantic Text Service modes

---

### 7.2 `service/html/HTML__Transformation__Service.py`

**Changes Required:**

1. **Add Dependency:**
```python
from mgraph_ai_service_mitmproxy.service.semantic_text.Semantic_Text__Service__Client import Semantic_Text__Service__Client
```

2. **Update Class:**
```python
class HTML__Transformation__Service(Type_Safe):
    html_service_client      : HTML__Service__Client  = None
    semantic_text_client     : Semantic_Text__Service__Client = None  # NEW
    cache_service            : Proxy__Cache__Service  = None
    
    def setup(self) -> 'HTML__Transformation__Service':
        self.html_service_client = HTML__Service__Client().setup()
        self.semantic_text_client = Semantic_Text__Service__Client().setup()  # NEW
        self.cache_service       = Proxy__Cache__Service().setup()
        return self
```

3. **Update `transform_html()` method:**
```python
def transform_html(self, source_html   : str,
                         target_url    : str,
                         mode          : Enum__HTML__Transformation_Mode
                   ) -> Schema__HTML__Transformation__Result:
    
    if not mode.is_active():
        return Schema__HTML__Transformation__Result(...)
    
    # Route to appropriate service
    if mode.is_html_service_transformation():
        return self._transform_via_html_service(source_html, mode)
    
    elif mode.is_semantic_text_transformation():
        return self._transform_via_semantic_text(source_html, target_url, mode)
    
    else:
        raise NotImplementedError(f"Transformation mode not supported: {mode}")
```

4. **Replace `_transform_locally()` with `_transform_via_semantic_text()`:**
```python
def _transform_via_semantic_text(self, 
                                 source_html: str,
                                 target_url: str,
                                 mode: Enum__HTML__Transformation_Mode
                                ) -> Schema__HTML__Transformation__Result:
    """
    Transform HTML via Semantic Text Service
    
    Flow:
    1. Get hash mapping from HTML Service
    2. Send hash_mapping to Semantic Text Service
    3. Reconstruct HTML with modified hashes
    """
    start_time = time.time()
    
    # Step 1: Get hash mapping
    dict_hashes_request = Schema__Html__To__Dict__Hashes__Request(html=source_html)
    dict_hashes_response = self.html_service_client.get_dict_hashes(dict_hashes_request)
    
    if not dict_hashes_response.is_successful():
        return self._error_result(source_html, mode, start_time)
    
    # Step 2: Transform via Semantic Text Service
    semantic_request = self._create_semantic_request(
        dict_hashes_response.hash_mapping,
        mode
    )
    
    semantic_response = self.semantic_text_client.transform_text(semantic_request)
    
    if not semantic_response.is_successful():
        return self._error_result(source_html, mode, start_time)
    
    # Step 3: Reconstruct HTML
    reconstruct_request = Schema__Hashes__To__Html__Request(
        html_dict    = dict_hashes_response.html_dict,
        hash_mapping = semantic_response.modified_hash_mapping
    )
    
    reconstruct_response = self.html_service_client.reconstruct_from_hashes(reconstruct_request)
    
    if not reconstruct_response.is_successful():
        return self._error_result(source_html, mode, start_time)
    
    call_duration_ms = (time.time() - start_time) * 1000
    
    return Schema__HTML__Transformation__Result(
        transformed_html       = reconstruct_response.body,
        transformation_mode    = mode,
        content_type           = "text/html",
        cache_hit              = False,
        transformation_time_ms = Safe_Float(call_duration_ms)
    )
```

5. **Add helper method:**
```python
def _create_semantic_request(self,
                            hash_mapping: Dict[Safe_Str__Hash, str],
                            mode: Enum__HTML__Transformation_Mode
                           ) -> Schema__Semantic_Text__Request__Base:
    """Create appropriate request schema for Semantic Text Service"""
    
    if mode == Enum__HTML__Transformation_Mode.XXX_RANDOM:
        return Schema__Semantic_Text__Request__XXX_Random(
            hash_mapping = hash_mapping
        )
    
    elif mode == Enum__HTML__Transformation_Mode.HASHES_RANDOM:
        return Schema__Semantic_Text__Request__Hashes_Random(
            hash_mapping = hash_mapping
        )
    
    elif mode == Enum__HTML__Transformation_Mode.ABCDE_BY_SIZE:
        return Schema__Semantic_Text__Request__ABCDE_By_Size(
            hash_mapping = hash_mapping,
            num_groups   = 5
        )
    
    else:
        raise ValueError(f"Unsupported semantic text mode: {mode}")
```

---

### 7.3 `service/proxy/Proxy__Debug__Service.py`

**Changes Required:**

**Remove WCF Integration:**
```python
# REMOVE this entire section:
if command.is_wcf_show_command():
    target_url = response_data.request.get('url')
    wcf_response = self.wcf_service.process_show_command(...)
    ...
```

**Update Class:**
```python
class Proxy__Debug__Service(Type_Safe):
    # wcf_service  : Proxy__WCF__Service      = None  # REMOVE
    html_service : Proxy__HTML__Service
    json_service : Proxy__JSON__Service

    def setup(self):
        # self.wcf_service = Proxy__WCF__Service().setup()  # REMOVE
        return self
```

**Update `process_show_command()` method:**
```python
def process_show_command(self, command       : Schema__Debug__Command,
                               response_data : Schema__Proxy__Response_Data
                        ) -> Optional[Schema__Proxy__Modifications]:
    
    # REMOVE: WCF command handling
    # if command.is_wcf_show_command():
    #     ...
    
    # KEEP: response-data show command
    if command.is_response_data_show_command():
        modifications = Schema__Proxy__Modifications()
        ...
        return modifications
    
    return None
```

---

### 7.4 `service/cache/schemas/Enum__Cache__Transformation_Type.py`

**Changes Required:**

1. **Remove Legacy WCF Types:**
```python
# REMOVE:
# URL_TO_HTML          = "url-to-html"
# URL_TO_LINES         = "url-to-lines"
# URL_TO_RATINGS       = "url-to-ratings"
# URL_TO_HTML_FILTERED = "url-to-html-min-rating"
```

2. **Keep HTML Service Types:**
```python
# KEEP (HTML Service):
HTML_TO_DICT      = "html-to-dict"
HTML_TO_XXX       = "html-to-xxx"
HTML_TO_HASHES    = "html-to-hashes"
HTML_TO_ROUNDTRIP = "html-to-roundtrip"
```

3. **Add Semantic Text Types:**
```python
# NEW (Semantic Text Service):
TEXT_XXX_RANDOM    = "text-xxx-random"
TEXT_HASHES_RANDOM = "text-hashes-random"
TEXT_ABCDE_BY_SIZE = "text-abcde-by-size"
```

4. **Update Methods:**
```python
def to_data_key(self) -> str:
    mapping = {
        # HTML Service transformations
        "html-to-dict"      : "transformations/html-dict",
        "html-to-xxx"       : "transformations/html-xxx",
        "html-to-hashes"    : "transformations/html-hashes",
        "html-to-roundtrip" : "transformations/html-roundtrip",
        
        # Semantic Text transformations
        "text-xxx-random"    : "transformations/text-xxx-random",
        "text-hashes-random" : "transformations/text-hashes-random",
        "text-abcde-by-size" : "transformations/text-abcde-by-size"
    }
    return mapping.get(self.value, f"transformations/{self.value}")

def is_html_service_transformation(self) -> bool:
    html_service_types = {
        Enum__Cache__Transformation_Type.HTML_TO_DICT,
        Enum__Cache__Transformation_Type.HTML_TO_XXX,
        Enum__Cache__Transformation_Type.HTML_TO_HASHES,
        Enum__Cache__Transformation_Type.HTML_TO_ROUNDTRIP
    }
    return self in html_service_types

def is_semantic_text_transformation(self) -> bool:
    semantic_text_types = {
        Enum__Cache__Transformation_Type.TEXT_XXX_RANDOM,
        Enum__Cache__Transformation_Type.TEXT_HASHES_RANDOM,
        Enum__Cache__Transformation_Type.TEXT_ABCDE_BY_SIZE
    }
    return self in semantic_text_types
```

---

### 7.5 `utils/deploy/Deploy__Service.py`

**Changes Required:**

**Add Semantic Text Service environment variables:**
```python
def deploy_lambda(self):
    with super().deploy_lambda() as _:
        # Existing...
        _.set_env_variable('AUTH__TARGET_SERVER__HTML_SERVICE__BASE_URL', ...)
        _.set_env_variable('AUTH__TARGET_SERVER__HTML_SERVICE__KEY_NAME', ...)
        _.set_env_variable('AUTH__TARGET_SERVER__HTML_SERVICE__KEY_VALUE', ...)
        
        # NEW: Semantic Text Service
        _.set_env_variable('AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__BASE_URL', 
                          get_env('AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__BASE_URL'))
        _.set_env_variable('AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_NAME', 
                          get_env('AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_NAME'))
        _.set_env_variable('AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_VALUE', 
                          get_env('AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_VALUE'))
        
        # REMOVE: WCF Service variables
        # _.set_env_variable('WCF_SERVICE__AUTH__API_KEY__NAME', ...)
        # _.set_env_variable('WCF_SERVICE__AUTH__API_KEY__VALUE', ...)
        
        return _
```

---

## 8. Cache Integration

### 8.1 Cache Structure (No Changes)

**Cache keys remain unchanged:**
```
sites/{domain}/pages/{path}/transformations/html-dict
sites/{domain}/pages/{path}/transformations/html-xxx
sites/{domain}/pages/{path}/transformations/html-hashes
sites/{domain}/pages/{path}/transformations/html-roundtrip
sites/{domain}/pages/{path}/transformations/text-xxx-random      # NEW
sites/{domain}/pages/{path}/transformations/text-hashes-random   # NEW
sites/{domain}/pages/{path}/transformations/text-abcde-by-size   # NEW
```

### 8.2 Cache Behavior

**No changes to:**
- `Proxy__Cache__Service.py` - Core cache logic
- Cache storage strategy
- Cache retrieval logic
- Cache invalidation (if any)

**Cache stats tracking:**
- Semantic Text transformations count as cache hits/misses like HTML Service

---

## 9. Error Handling Strategy

### 9.1 Semantic Text Service Errors

```python
class Semantic_Text__Service__Client:
    
    def transform_text(self, request) -> Schema__Semantic_Text__Response:
        try:
            response = requests.post(...)
            
            if response.status_code == 200:
                return Schema__Semantic_Text__Response(
                    status_code = 200,
                    modified_hash_mapping = response.json()['modified_hash_mapping'],
                    success = True,
                    processing_time_ms = ...
                )
            
            else:
                return Schema__Semantic_Text__Response(
                    status_code = response.status_code,
                    modified_hash_mapping = {},
                    success = False,
                    error_message = f"Semantic Text API error: {response.status_code}",
                    processing_time_ms = ...
                )
        
        except requests.Timeout:
            return Schema__Semantic_Text__Response(
                status_code = 504,
                modified_hash_mapping = {},
                success = False,
                error_message = "Semantic Text Service timeout"
            )
        
        except Exception as e:
            return Schema__Semantic_Text__Response(
                status_code = 500,
                modified_hash_mapping = {},
                success = False,
                error_message = f"Unexpected error: {str(e)}"
            )
```

### 9.2 Fallback Behavior

**On Semantic Text Service failure:**
1. Log error with full context
2. Return original HTML unchanged
3. Add header: `x-transformation-error: semantic-text-service-unavailable`
4. Cache stats: Count as transformation failure (not cache miss)

**Example:**
```python
def _transform_via_semantic_text(self, source_html, target_url, mode):
    ...
    if not semantic_response.is_successful():
        print(f"âš ï¸  Semantic Text Service error: {semantic_response.error_message}")
        return Schema__HTML__Transformation__Result(
            transformed_html       = source_html,  # Return original
            transformation_mode    = mode,
            content_type           = "text/html",
            cache_hit              = False,
            transformation_time_ms = Safe_Float(call_duration_ms)
        )
```

---

## 10. Testing Strategy

### 10.1 Unit Tests Required

**New Service Tests:**
```
tests/unit/service/semantic_text/test__Semantic_Text__Service__Client.py
tests/unit/service/semantic_text/test__Semantic_Text__Transformation__Service.py
```

**Updated Service Tests:**
```
tests/unit/service/html/test__HTML__Transformation__Service.py
  - Update to test routing logic
  - Test Semantic Text integration
  - Test error handling
```

### 10.2 Integration Tests Required

**Semantic Text Integration:**
```
tests/integration/test__semantic_text_integration.py
  - Test xxx-random transformation end-to-end
  - Test hashes-random transformation end-to-end
  - Test abcde-by-size transformation end-to-end
  - Test error handling with service unavailable
  - Test timeout scenarios
```

**Cache Integration:**
```
tests/integration/test__semantic_text_caching.py
  - Test cache hit/miss for Semantic Text transformations
  - Test cache key generation
  - Verify cache structure unchanged
```

### 10.3 Regression Tests

**Verify No Breaking Changes:**
```
tests/regression/test__html_service_unchanged.py
  - Test DICT mode still works
  - Test XXX mode still works
  - Test HASHES mode still works
  - Test ROUNDTRIP mode still works
```

**Cookie Behavior:**
```
tests/regression/test__cookie_behavior.py
  - Test mitm-mode=xxx-random cookie
  - Test mitm-mode=hashes-random cookie
  - Test mitm-mode=abcde-by-size cookie
  - Verify headers unchanged
```

---

## 11. Migration Path

### 11.1 Phase 1: Foundation (Week 1)

**Day 1-2: Schema Layer**
- Create all schemas in `schemas/semantic_text/`
- Create constants in `service/consts/consts__semantic_text.py`
- Update `Enum__HTML__Transformation_Mode` with routing methods

**Day 3-4: Service Client**
- Implement `Semantic_Text__Service__Client.py`
- Add authentication from environment
- Implement all three transformation endpoints
- Unit tests for client

**Day 5: Service Integration**
- Implement `Semantic_Text__Transformation__Service.py`
- Add cache integration
- Unit tests for service

### 11.2 Phase 2: Integration (Week 2)

**Day 1-2: Update HTML__Transformation__Service**
- Add Semantic Text client dependency
- Implement `_transform_via_semantic_text()` method
- Update routing logic in `transform_html()`
- Refactor existing `_transform_via_html_service()` method

**Day 3: Update Dependencies**
- Remove WCF service from `Proxy__Debug__Service`
- Update cache transformation types
- Update deployment configuration

**Day 4-5: Testing**
- Integration tests
- Regression tests
- Performance testing

### 11.3 Phase 3: Cleanup & Deployment (Week 3)

**Day 1-2: Remove WCF Code**
- Delete all WCF service files
- Delete all WCF schema files
- Remove WCF dependencies from other services
- Update imports across codebase

**Day 3: Remove Local Transformation Code**
- Delete `HTML__Transformation__Service__Local.py`
- Delete `Text__Grouping__Service.py`
- Remove local transformation methods

**Day 4: Documentation & Deployment**
- Update README
- Update API documentation
- Deploy to staging
- Validate in staging environment

**Day 5: Production Deployment**
- Deploy to production
- Monitor logs for errors
- Verify cache hit rates
- Performance monitoring

---

## 12. Validation Criteria

### 12.1 Functional Requirements

âœ… All existing transformation modes work identically from user perspective  
âœ… xxx-random produces visually similar results to old implementation  
âœ… hashes-random produces visually similar results to old implementation  
âœ… abcde-by-size produces visually similar results to old implementation  
âœ… HTML Service transformations (DICT, XXX, HASHES, ROUNDTRIP) unchanged  
âœ… Cache hit rates remain similar or improve  
âœ… Cookie-based mode selection works identically  
âœ… Error messages are informative and actionable  

### 12.2 Performance Requirements

âœ… Transformation time <= 2x current local implementation  
âœ… Cache hit rate >= 80% in production  
âœ… Service timeout set to 30 seconds (configurable)  
âœ… No performance regression for HTML Service transformations  

### 12.3 Code Quality Requirements

âœ… All new code has >= 80% test coverage  
âœ… All Type_Safe schemas properly validated  
âœ… No code duplication between services  
âœ… Clear separation of concerns maintained  
âœ… All TODOs resolved or tracked in issues  

---

## 13. Rollback Plan

### 13.1 Immediate Rollback Triggers

**Critical Issues:**
- Semantic Text Service unavailable for > 5 minutes
- Transformation errors > 10% of requests
- Cache hit rate drops below 50%
- Production errors related to new code

### 13.2 Rollback Procedure

**Step 1: Revert Deployment**
```bash
# Revert to previous Lambda version
aws lambda update-function-configuration \
  --function-name mgraph-ai-service-mitmproxy \
  --environment Variables=ROLLBACK=true
```

**Step 2: Re-enable Local Transformations (Emergency)**
- Uncomment `HTML__Transformation__Service__Local.py`
- Restore `_transform_locally()` method
- Deploy hotfix

**Step 3: Communication**
- Notify team of rollback
- Document failure reason
- Create incident report

---

## 14. Monitoring & Observability

### 14.1 Metrics to Track

**Service Health:**
- Semantic Text Service response time (p50, p95, p99)
- Semantic Text Service error rate
- Semantic Text Service timeout rate

**Transformation Metrics:**
- Transformations by mode (xxx-random, hashes-random, abcde-by-size)
- Transformation success rate
- Transformation cache hit rate

**Performance Metrics:**
- End-to-end transformation time
- HTML Service vs Semantic Text Service latency comparison

### 14.2 Logging Requirements

**Log Transformation Requests:**
```python
print(f"    ğŸ”„ Semantic Text: {mode.value} transformation for {target_url}")
print(f"       Semantic Text took {duration_ms/1000:.2f}s")
```

**Log Cache Operations:**
```python
print(f"         >>> Cache HIT for semantic-text/{mode.value}: {target_url}")
print(f"         >>> Cached semantic-text/{mode.value} transformation")
```

**Log Errors:**
```python
print(f"    âš ï¸  Semantic Text Service error: {error_message}")
print(f"    âš ï¸  Falling back to original HTML")
```

---

## 15. Dependencies & Prerequisites

### 15.1 External Dependencies

**Required Services:**
- âœ… Semantic Text Service deployed and operational
- âœ… Semantic Text Service API key provisioned
- âœ… HTML Service operational (existing dependency)
- âœ… Cache Service operational (existing dependency)

### 15.2 Environment Setup

**New Environment Variables:**
```bash
AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__BASE_URL=https://semantic-text.dev.mgraph.ai
AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_NAME=x-api-key
AUTH__TARGET_SERVER__SEMANTIC_TEXT_SERVICE__KEY_VALUE=<provided-api-key>
```

### 15.3 Code Dependencies

**New Python Dependencies:**
- None (using existing `requests` library)

**Internal Dependencies:**
- `mgraph_ai_service_cache_client` (existing)
- `osbot-fast-api` (existing)
- `osbot-utils` (existing)

---

## 16. Open Questions & Decisions Needed

### 16.1 Resolved via Conversation

âœ… **Q:** Which transformations migrate to Semantic Text?  
**A:** xxx-random, hashes-random, abcde-by-size

âœ… **Q:** What happens to WCF code?  
**A:** Complete removal (ignore url_to_* for now)

âœ… **Q:** Cache structure changes?  
**A:** No changes, keep existing structure

âœ… **Q:** Are there backward compatibility requirements?  
**A:** Yes, zero breaking changes for API consumers

### 16.2 Outstanding Questions

â“ **Q:** Should we add rate limiting for Semantic Text Service calls?  
**Recommendation:** Implement client-side rate limiting (100 requests/minute) to protect against runaway requests

â“ **Q:** Should we implement circuit breaker pattern for Semantic Text Service?  
**Recommendation:** Yes, implement circuit breaker with 5 failures = circuit open for 60 seconds

â“ **Q:** Should we add request/response validation against OpenAPI schema?  
**Recommendation:** Yes, add runtime validation in development mode

---

## 17. Success Metrics (Post-Deployment)

### 17.1 Week 1 Metrics

- [ ] Zero production errors related to Semantic Text integration
- [ ] Semantic Text Service response time p95 < 2 seconds
- [ ] Cache hit rate >= 70%
- [ ] Transformation success rate >= 99%

### 17.2 Month 1 Metrics

- [ ] Cache hit rate >= 85%
- [ ] Average transformation time decreased by 20%
- [ ] Zero customer complaints about transformation quality
- [ ] All monitoring dashboards operational

---

## 18. Appendix

### 18.1 OpenAPI Schema Mapping

**Transformation Endpoints:**
```
POST /text-transformation/transform/xxx-random
  Request: Schema__Text__Transformation__Request__XXX_Random__BaseModel
  Response: { modified_hash_mapping: Dict[str, str] }

POST /text-transformation/transform/hashes-random
  Request: Schema__Text__Transformation__Request__Hashes_Random__BaseModel
  Response: { modified_hash_mapping: Dict[str, str] }

POST /text-transformation/transform/abcde-by-size
  Request: Schema__Text__Transformation__Request__ABCDE_By_Size__BaseModel
  Response: { modified_hash_mapping: Dict[str, str] }
```

### 18.2 File Structure (Post-Refactoring)

```
mgraph_ai_service_mitmproxy/
â”œâ”€â”€ schemas/
â”‚   â”œâ”€â”€ semantic_text/               # NEW
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ Enum__Semantic_Text__Transformation_Mode.py
â”‚   â”‚   â”œâ”€â”€ Schema__Semantic_Text__Request.py
â”‚   â”‚   â”œâ”€â”€ Schema__Semantic_Text__Response.py
â”‚   â”‚   â””â”€â”€ Schema__Semantic_Text__Transformation__Result.py
â”‚   â”œâ”€â”€ html/
â”‚   â”‚   â””â”€â”€ Enum__HTML__Transformation_Mode.py  # MODIFIED
â”‚   â””â”€â”€ [wcf/ removed]               # REMOVED
â”‚
â”œâ”€â”€ service/
â”‚   â”œâ”€â”€ semantic_text/               # NEW
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ Semantic_Text__Service__Client.py
â”‚   â”‚   â””â”€â”€ Semantic_Text__Transformation__Service.py
â”‚   â”œâ”€â”€ html/
â”‚   â”‚   â”œâ”€â”€ HTML__Transformation__Service.py  # MODIFIED
â”‚   â”‚   â””â”€â”€ [HTML__Transformation__Service__Local.py removed]  # REMOVED
â”‚   â”‚   â””â”€â”€ [Text__Grouping__Service.py removed]  # REMOVED
â”‚   â”œâ”€â”€ proxy/
â”‚   â”‚   â”œâ”€â”€ Proxy__Debug__Service.py  # MODIFIED
â”‚   â”‚   â””â”€â”€ response/
â”‚   â”‚       â””â”€â”€ Proxy__Response__Service.py  # MODIFIED
â”‚   â”œâ”€â”€ cache/
â”‚   â”‚   â””â”€â”€ schemas/
â”‚   â”‚       â””â”€â”€ Enum__Cache__Transformation_Type.py  # MODIFIED
â”‚   â”œâ”€â”€ consts/
â”‚   â”‚   â””â”€â”€ consts__semantic_text.py  # NEW
â”‚   â””â”€â”€ [wcf/ removed]               # REMOVED
â”‚
â””â”€â”€ utils/
    â””â”€â”€ deploy/
        â””â”€â”€ Deploy__Service.py       # MODIFIED
```